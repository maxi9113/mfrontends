{"ast":null,"code":"import React, { Component, cloneElement, isValidElement } from 'react';\nimport adler32 from 'react-lib-adler32';\nconst isDevEnv = process.env.NODE_ENV !== 'production';\n\nclass Style extends Component {\n  constructor() {\n    super(...arguments);\n    this.scopeClassNameCache = {};\n    this.scopedCSSTextCache = {};\n    this.scoped = this.props.scoped !== undefined ? this.props.scoped : true;\n    this.pepper = '';\n\n    this.getStyleString = () => {\n      if (this.props.children instanceof Array) {\n        const styleString = this.props.children.filter(child => !isValidElement(child) && typeof child === 'string');\n\n        if (styleString.length > 1) {\n          throw new Error(`Multiple style objects as direct descedents of a\n        Style component are not supported (${styleString.length} style objects detected):\n\n        ${styleString[0]}\n        `);\n        }\n\n        return styleString[0];\n      }\n\n      if (typeof this.props.children === 'string' && !isValidElement(this.props.children)) {\n        return this.props.children;\n      }\n\n      return null;\n    };\n\n    this.getRootElement = () => {\n      if (this.props.children instanceof Array) {\n        const rootElement = this.props.children.filter(child => isValidElement(child));\n\n        if (isDevEnv) {\n          if (rootElement.length > 1) {\n            console.log(rootElement);\n            throw new Error(`Adjacent JSX elements must be wrapped in an enclosing tag \n          (${rootElement.length} root elements detected)`);\n          }\n\n          if (typeof rootElement[0] !== 'undefined' && this.isVoidElement(rootElement[0].type)) {\n            throw new Error(`Self-closing void elements like ${rootElement.type} must be \n          wrapped in an enclosing tag. Reactive Style must be able to nest a style element inside of the \n          root element and void element content models never \n          allow it to have contents under any circumstances.`);\n          }\n        }\n\n        return rootElement[0];\n      }\n\n      if (isValidElement(this.props.children)) {\n        return this.props.children;\n      }\n\n      return null;\n    };\n\n    this.getRootSelectors = rootElement => {\n      const rootSelectors = [];\n\n      if (rootElement.props.id) {\n        rootSelectors.push(`#${rootElement.props.id}`);\n      }\n\n      if (rootElement.props.className) {\n        rootElement.props.className.trim().split(/\\s+/g).forEach(className => rootSelectors.push(className));\n      }\n\n      if (!rootSelectors.length && typeof rootElement.type !== 'function') {\n        rootSelectors.push(rootElement.type);\n      }\n\n      return rootSelectors;\n    };\n\n    this.processCSSText = (styleString, scopeClassName, rootSelectors) => {\n      return styleString.replace(/\\s*\\/\\/(?![^(]*\\)).*|\\s*\\/\\*.*\\*\\//g, '').replace(/\\s\\s+/g, ' ').split('}').map(fragment => {\n        const isDeclarationBodyPattern = /.*:.*;/g;\n        const isLastItemDeclarationBodyPattern = /.*:.*(;|$|\\s+)/g;\n        const isAtRulePattern = /\\s*@/g;\n        const isKeyframeOffsetPattern = /\\s*(([0-9][0-9]?|100)\\s*%)|\\s*(to|from)\\s*$/g;\n        return fragment.split('{').map((statement, i, arr) => {\n          if (!statement.trim().length) {\n            return '';\n          }\n\n          const isDeclarationBodyItemWithOptionalSemicolon = arr.length - 1 === i && statement.match(isLastItemDeclarationBodyPattern);\n\n          if (statement.match(isDeclarationBodyPattern) || isDeclarationBodyItemWithOptionalSemicolon) {\n            return this.escapeTextContentForBrowser(statement);\n          }\n\n          const selector = statement;\n\n          if (scopeClassName && !/:target/gi.test(selector)) {\n            if (!selector.match(isAtRulePattern) && !selector.match(isKeyframeOffsetPattern)) {\n              return this.scopeSelector(scopeClassName, selector, rootSelectors);\n            }\n\n            return selector;\n          }\n\n          return selector;\n        }).join('{\\n');\n      }).join('}\\n');\n    };\n\n    this.escaper = match => {\n      const ESCAPE_LOOKUP = {\n        '>': '&gt;',\n        '<': '&lt;'\n      };\n      return ESCAPE_LOOKUP[match];\n    };\n\n    this.escapeTextContentForBrowser = text => {\n      const ESCAPE_REGEX = /[><]/g;\n      return `${text}`.replace(ESCAPE_REGEX, this.escaper);\n    };\n\n    this.scopeSelector = (scopeClassName, selector, rootSelectors) => {\n      const scopedSelector = [];\n      const groupOfSelectorsPattern = /,(?![^(|[]*\\)|\\])/g;\n      const selectors = selector.split(groupOfSelectorsPattern);\n      selectors.forEach(selectorElement => {\n        var _a, _b, _c;\n\n        let containsSelector;\n        let unionSelector;\n\n        if (((_a = rootSelectors) === null || _a === void 0 ? void 0 : _a.length) && rootSelectors.some(rootSelector => selectorElement.match(rootSelector))) {\n          unionSelector = selectorElement;\n          const escapedRootSelectors = (_b = rootSelectors) === null || _b === void 0 ? void 0 : _b.map(rootSelector => rootSelector.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'));\n          unionSelector = unionSelector.replace(new RegExp(`(${(_c = escapedRootSelectors) === null || _c === void 0 ? void 0 : _c.join('|')})`), `$1${scopeClassName}`);\n          containsSelector = this.scoped ? `${scopeClassName} ${selectorElement}` : selectorElement;\n          scopedSelector.push(unionSelector, containsSelector);\n        } else {\n          containsSelector = this.scoped ? `${scopeClassName} ${selectorElement}` : selectorElement;\n          scopedSelector.push(containsSelector);\n        }\n      });\n\n      if (!this.scoped && scopedSelector.length > 1) {\n        return scopedSelector[1];\n      }\n\n      return scopedSelector.join(', ');\n    };\n\n    this.getScopeClassName = (styleString, rootElement) => {\n      let hash = styleString;\n\n      if (rootElement) {\n        this.pepper = '';\n        this.traverseObjectToGeneratePepper(rootElement);\n        hash += this.pepper;\n      }\n\n      return (isDevEnv ? 'scope-' : 's') + adler32(hash);\n    };\n\n    this.traverseObjectToGeneratePepper = (obj, depth = 0) => {\n      if (depth > 32 || this.pepper.length > 10000) return;\n      Object.keys(obj).forEach(prop => {\n        const isPropReactInternal = /^[_$]|type|ref|^value$/.test(prop);\n\n        if (!!obj[prop] && typeof obj[prop] === 'object' && !isPropReactInternal) {\n          this.traverseObjectToGeneratePepper(obj[prop], depth + 1);\n        } else if (!!obj[prop] && !isPropReactInternal && typeof obj[prop] !== 'function') {\n          this.pepper += obj[prop];\n        }\n      });\n    };\n\n    this.isVoidElement = type => ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'].some(voidType => type === voidType);\n\n    this.createStyleElement = (cssText, scopeClassName) => {\n      return React.createElement(\"style\", {\n        id: 'direflow_styles',\n        type: 'text/css',\n        key: scopeClassName,\n        // eslint-disable-next-line react/no-danger\n        dangerouslySetInnerHTML: {\n          __html: cssText || ''\n        }\n      });\n    };\n\n    this.getNewChildrenForCloneElement = (cssText, rootElement, scopeClassName) => {\n      return [this.createStyleElement(cssText, scopeClassName)].concat(rootElement.props.children);\n    };\n  }\n\n  render() {\n    const styleString = this.getStyleString();\n    const rootElement = this.getRootElement();\n\n    if (!styleString && rootElement) {\n      return rootElement.props.children;\n    }\n\n    if (styleString && !rootElement) {\n      return this.createStyleElement(this.processCSSText(styleString), this.getScopeClassName(styleString, rootElement));\n    }\n\n    const rootElementId = rootElement.props.id ? rootElement.props.id : '';\n    const rootElementClassNames = rootElement.props.className ? `${rootElement.props.className} ` : '';\n    let scopeClassName;\n    let scopedCSSText;\n    const scopeClassNameAddress = rootElementClassNames + rootElementId + styleString;\n\n    if (this.scopeClassNameCache[scopeClassNameAddress]) {\n      scopeClassName = this.scopeClassNameCache[scopeClassNameAddress];\n      scopedCSSText = this.scopedCSSTextCache[scopeClassName];\n    } else {\n      scopeClassName = this.getScopeClassName(styleString, rootElement);\n      scopedCSSText = this.processCSSText(styleString, `.${scopeClassName}`, this.getRootSelectors(rootElement));\n      this.scopeClassNameCache[scopeClassNameAddress] = scopeClassName;\n      this.scopedCSSTextCache[scopeClassName] = scopedCSSText;\n    }\n\n    const className = this.scoped ? `${rootElementClassNames}${scopeClassName}` : rootElementClassNames;\n    return cloneElement(rootElement, Object.assign(Object.assign({}, rootElement.props), {\n      className: className.trim()\n    }), this.getNewChildrenForCloneElement(scopedCSSText, rootElement, scopeClassName));\n  }\n\n}\n\nexport default Style;","map":{"version":3,"sources":["/home/max-valeta/Documents/ALTO/react/container-mfs/public/mf-task/node_modules/direflow-component/dist/helpers/styleInjector.js"],"names":["React","Component","cloneElement","isValidElement","adler32","isDevEnv","process","env","NODE_ENV","Style","constructor","arguments","scopeClassNameCache","scopedCSSTextCache","scoped","props","undefined","pepper","getStyleString","children","Array","styleString","filter","child","length","Error","getRootElement","rootElement","console","log","isVoidElement","type","getRootSelectors","rootSelectors","id","push","className","trim","split","forEach","processCSSText","scopeClassName","replace","map","fragment","isDeclarationBodyPattern","isLastItemDeclarationBodyPattern","isAtRulePattern","isKeyframeOffsetPattern","statement","i","arr","isDeclarationBodyItemWithOptionalSemicolon","match","escapeTextContentForBrowser","selector","test","scopeSelector","join","escaper","ESCAPE_LOOKUP","text","ESCAPE_REGEX","scopedSelector","groupOfSelectorsPattern","selectors","selectorElement","_a","_b","_c","containsSelector","unionSelector","some","rootSelector","escapedRootSelectors","RegExp","getScopeClassName","hash","traverseObjectToGeneratePepper","obj","depth","Object","keys","prop","isPropReactInternal","voidType","createStyleElement","cssText","createElement","key","dangerouslySetInnerHTML","__html","getNewChildrenForCloneElement","concat","render","rootElementId","rootElementClassNames","scopedCSSText","scopeClassNameAddress","assign"],"mappings":"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","sourcesContent":["import React, { Component, cloneElement, isValidElement } from 'react';\nimport adler32 from 'react-lib-adler32';\nconst isDevEnv = process.env.NODE_ENV !== 'production';\nclass Style extends Component {\n    constructor() {\n        super(...arguments);\n        this.scopeClassNameCache = {};\n        this.scopedCSSTextCache = {};\n        this.scoped = this.props.scoped !== undefined ? this.props.scoped : true;\n        this.pepper = '';\n        this.getStyleString = () => {\n            if (this.props.children instanceof Array) {\n                const styleString = this.props.children.filter((child) => !isValidElement(child) && typeof child === 'string');\n                if (styleString.length > 1) {\n                    throw new Error(`Multiple style objects as direct descedents of a\n        Style component are not supported (${styleString.length} style objects detected):\n\n        ${styleString[0]}\n        `);\n                }\n                return styleString[0];\n            }\n            if (typeof this.props.children === 'string' && !isValidElement(this.props.children)) {\n                return this.props.children;\n            }\n            return null;\n        };\n        this.getRootElement = () => {\n            if (this.props.children instanceof Array) {\n                const rootElement = this.props.children.filter((child) => isValidElement(child));\n                if (isDevEnv) {\n                    if (rootElement.length > 1) {\n                        console.log(rootElement);\n                        throw new Error(`Adjacent JSX elements must be wrapped in an enclosing tag \n          (${rootElement.length} root elements detected)`);\n                    }\n                    if (typeof rootElement[0] !== 'undefined' &&\n                        this.isVoidElement(rootElement[0].type)) {\n                        throw new Error(`Self-closing void elements like ${rootElement.type} must be \n          wrapped in an enclosing tag. Reactive Style must be able to nest a style element inside of the \n          root element and void element content models never \n          allow it to have contents under any circumstances.`);\n                    }\n                }\n                return rootElement[0];\n            }\n            if (isValidElement(this.props.children)) {\n                return this.props.children;\n            }\n            return null;\n        };\n        this.getRootSelectors = (rootElement) => {\n            const rootSelectors = [];\n            if (rootElement.props.id) {\n                rootSelectors.push(`#${rootElement.props.id}`);\n            }\n            if (rootElement.props.className) {\n                rootElement.props.className\n                    .trim()\n                    .split(/\\s+/g)\n                    .forEach((className) => rootSelectors.push(className));\n            }\n            if (!rootSelectors.length && typeof rootElement.type !== 'function') {\n                rootSelectors.push(rootElement.type);\n            }\n            return rootSelectors;\n        };\n        this.processCSSText = (styleString, scopeClassName, rootSelectors) => {\n            return styleString\n                .replace(/\\s*\\/\\/(?![^(]*\\)).*|\\s*\\/\\*.*\\*\\//g, '')\n                .replace(/\\s\\s+/g, ' ')\n                .split('}')\n                .map((fragment) => {\n                const isDeclarationBodyPattern = /.*:.*;/g;\n                const isLastItemDeclarationBodyPattern = /.*:.*(;|$|\\s+)/g;\n                const isAtRulePattern = /\\s*@/g;\n                const isKeyframeOffsetPattern = /\\s*(([0-9][0-9]?|100)\\s*%)|\\s*(to|from)\\s*$/g;\n                return fragment\n                    .split('{')\n                    .map((statement, i, arr) => {\n                    if (!statement.trim().length) {\n                        return '';\n                    }\n                    const isDeclarationBodyItemWithOptionalSemicolon = arr.length - 1 === i && statement.match(isLastItemDeclarationBodyPattern);\n                    if (statement.match(isDeclarationBodyPattern) ||\n                        isDeclarationBodyItemWithOptionalSemicolon) {\n                        return this.escapeTextContentForBrowser(statement);\n                    }\n                    const selector = statement;\n                    if (scopeClassName && !/:target/gi.test(selector)) {\n                        if (!selector.match(isAtRulePattern) && !selector.match(isKeyframeOffsetPattern)) {\n                            return this.scopeSelector(scopeClassName, selector, rootSelectors);\n                        }\n                        return selector;\n                    }\n                    return selector;\n                })\n                    .join('{\\n');\n            })\n                .join('}\\n');\n        };\n        this.escaper = (match) => {\n            const ESCAPE_LOOKUP = {\n                '>': '&gt;',\n                '<': '&lt;',\n            };\n            return ESCAPE_LOOKUP[match];\n        };\n        this.escapeTextContentForBrowser = (text) => {\n            const ESCAPE_REGEX = /[><]/g;\n            return `${text}`.replace(ESCAPE_REGEX, this.escaper);\n        };\n        this.scopeSelector = (scopeClassName, selector, rootSelectors) => {\n            const scopedSelector = [];\n            const groupOfSelectorsPattern = /,(?![^(|[]*\\)|\\])/g;\n            const selectors = selector.split(groupOfSelectorsPattern);\n            selectors.forEach((selectorElement) => {\n                var _a, _b, _c;\n                let containsSelector;\n                let unionSelector;\n                if (((_a = rootSelectors) === null || _a === void 0 ? void 0 : _a.length) &&\n                    rootSelectors.some((rootSelector) => selectorElement.match(rootSelector))) {\n                    unionSelector = selectorElement;\n                    const escapedRootSelectors = (_b = rootSelectors) === null || _b === void 0 ? void 0 : _b.map((rootSelector) => rootSelector.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'));\n                    unionSelector = unionSelector.replace(new RegExp(`(${(_c = escapedRootSelectors) === null || _c === void 0 ? void 0 : _c.join('|')})`), `$1${scopeClassName}`);\n                    containsSelector = this.scoped ? `${scopeClassName} ${selectorElement}` : selectorElement;\n                    scopedSelector.push(unionSelector, containsSelector);\n                }\n                else {\n                    containsSelector = this.scoped ? `${scopeClassName} ${selectorElement}` : selectorElement;\n                    scopedSelector.push(containsSelector);\n                }\n            });\n            if (!this.scoped && scopedSelector.length > 1) {\n                return scopedSelector[1];\n            }\n            return scopedSelector.join(', ');\n        };\n        this.getScopeClassName = (styleString, rootElement) => {\n            let hash = styleString;\n            if (rootElement) {\n                this.pepper = '';\n                this.traverseObjectToGeneratePepper(rootElement);\n                hash += this.pepper;\n            }\n            return (isDevEnv ? 'scope-' : 's') + adler32(hash);\n        };\n        this.traverseObjectToGeneratePepper = (obj, depth = 0) => {\n            if (depth > 32 || this.pepper.length > 10000)\n                return;\n            Object.keys(obj).forEach((prop) => {\n                const isPropReactInternal = /^[_$]|type|ref|^value$/.test(prop);\n                if (!!obj[prop] && typeof obj[prop] === 'object' && !isPropReactInternal) {\n                    this.traverseObjectToGeneratePepper(obj[prop], depth + 1);\n                }\n                else if (!!obj[prop] && !isPropReactInternal && typeof obj[prop] !== 'function') {\n                    this.pepper += obj[prop];\n                }\n            });\n        };\n        this.isVoidElement = (type) => [\n            'area',\n            'base',\n            'br',\n            'col',\n            'command',\n            'embed',\n            'hr',\n            'img',\n            'input',\n            'keygen',\n            'link',\n            'meta',\n            'param',\n            'source',\n            'track',\n            'wbr',\n        ].some((voidType) => type === voidType);\n        this.createStyleElement = (cssText, scopeClassName) => {\n            return (React.createElement(\"style\", { id: 'direflow_styles', type: 'text/css', key: scopeClassName, \n                // eslint-disable-next-line react/no-danger\n                dangerouslySetInnerHTML: { __html: cssText || '' } }));\n        };\n        this.getNewChildrenForCloneElement = (cssText, rootElement, scopeClassName) => {\n            return [this.createStyleElement(cssText, scopeClassName)].concat(rootElement.props.children);\n        };\n    }\n    render() {\n        const styleString = this.getStyleString();\n        const rootElement = this.getRootElement();\n        if (!styleString && rootElement) {\n            return rootElement.props.children;\n        }\n        if (styleString && !rootElement) {\n            return this.createStyleElement(this.processCSSText(styleString), this.getScopeClassName(styleString, rootElement));\n        }\n        const rootElementId = rootElement.props.id ? rootElement.props.id : '';\n        const rootElementClassNames = rootElement.props.className\n            ? `${rootElement.props.className} `\n            : '';\n        let scopeClassName;\n        let scopedCSSText;\n        const scopeClassNameAddress = rootElementClassNames + rootElementId + styleString;\n        if (this.scopeClassNameCache[scopeClassNameAddress]) {\n            scopeClassName = this.scopeClassNameCache[scopeClassNameAddress];\n            scopedCSSText = this.scopedCSSTextCache[scopeClassName];\n        }\n        else {\n            scopeClassName = this.getScopeClassName(styleString, rootElement);\n            scopedCSSText = this.processCSSText(styleString, `.${scopeClassName}`, this.getRootSelectors(rootElement));\n            this.scopeClassNameCache[scopeClassNameAddress] = scopeClassName;\n            this.scopedCSSTextCache[scopeClassName] = scopedCSSText;\n        }\n        const className = this.scoped\n            ? `${rootElementClassNames}${scopeClassName}`\n            : rootElementClassNames;\n        return cloneElement(rootElement, Object.assign(Object.assign({}, rootElement.props), { className: className.trim() }), this.getNewChildrenForCloneElement(scopedCSSText, rootElement, scopeClassName));\n    }\n}\nexport default Style;\n"]},"metadata":{},"sourceType":"module"}